// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// CreatorSetting is an object representing the database table.
type CreatorSetting struct {
	ID                         uint64      `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatorChannelID           string      `boil:"creator_channel_id" json:"creator_channel_id" toml:"creator_channel_id" yaml:"creator_channel_id"`
	CommentsEnabled            null.Bool   `boil:"comments_enabled" json:"comments_enabled,omitempty" toml:"comments_enabled" yaml:"comments_enabled,omitempty"`
	MinTipAmountComment        null.Uint64 `boil:"min_tip_amount_comment" json:"min_tip_amount_comment,omitempty" toml:"min_tip_amount_comment" yaml:"min_tip_amount_comment,omitempty"`
	MinTipAmountSuperChat      null.Uint64 `boil:"min_tip_amount_super_chat" json:"min_tip_amount_super_chat,omitempty" toml:"min_tip_amount_super_chat" yaml:"min_tip_amount_super_chat,omitempty"`
	MutedWords                 null.String `boil:"muted_words" json:"muted_words,omitempty" toml:"muted_words" yaml:"muted_words,omitempty"`
	CreatedAt                  time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                  time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	SlowModeMinGap             null.Uint64 `boil:"slow_mode_min_gap" json:"slow_mode_min_gap,omitempty" toml:"slow_mode_min_gap" yaml:"slow_mode_min_gap,omitempty"`
	CurseJarAmount             null.Uint64 `boil:"curse_jar_amount" json:"curse_jar_amount,omitempty" toml:"curse_jar_amount" yaml:"curse_jar_amount,omitempty"`
	IsFiltersEnabled           null.Bool   `boil:"is_filters_enabled" json:"is_filters_enabled,omitempty" toml:"is_filters_enabled" yaml:"is_filters_enabled,omitempty"`
	ChatOverlay                bool        `boil:"chat_overlay" json:"chat_overlay" toml:"chat_overlay" yaml:"chat_overlay"`
	ChatOverlayPosition        string      `boil:"chat_overlay_position" json:"chat_overlay_position" toml:"chat_overlay_position" yaml:"chat_overlay_position"`
	ChatRemoveComment          int64       `boil:"chat_remove_comment" json:"chat_remove_comment" toml:"chat_remove_comment" yaml:"chat_remove_comment"`
	StickerOverlay             bool        `boil:"sticker_overlay" json:"sticker_overlay" toml:"sticker_overlay" yaml:"sticker_overlay"`
	StickerOverlayKeep         bool        `boil:"sticker_overlay_keep" json:"sticker_overlay_keep" toml:"sticker_overlay_keep" yaml:"sticker_overlay_keep"`
	StickerOverlayRemove       int64       `boil:"sticker_overlay_remove" json:"sticker_overlay_remove" toml:"sticker_overlay_remove" yaml:"sticker_overlay_remove"`
	ViewercountOverlay         bool        `boil:"viewercount_overlay" json:"viewercount_overlay" toml:"viewercount_overlay" yaml:"viewercount_overlay"`
	ViewercountOverlayPosition string      `boil:"viewercount_overlay_position" json:"viewercount_overlay_position" toml:"viewercount_overlay_position" yaml:"viewercount_overlay_position"`
	ViewercountChatBot         bool        `boil:"viewercount_chat_bot" json:"viewercount_chat_bot" toml:"viewercount_chat_bot" yaml:"viewercount_chat_bot"`
	TipgoalOverlay             bool        `boil:"tipgoal_overlay" json:"tipgoal_overlay" toml:"tipgoal_overlay" yaml:"tipgoal_overlay"`
	TipgoalAmount              int64       `boil:"tipgoal_amount" json:"tipgoal_amount" toml:"tipgoal_amount" yaml:"tipgoal_amount"`
	TipgoalOverlayPosition     string      `boil:"tipgoal_overlay_position" json:"tipgoal_overlay_position" toml:"tipgoal_overlay_position" yaml:"tipgoal_overlay_position"`
	TipgoalPreviousDonations   bool        `boil:"tipgoal_previous_donations" json:"tipgoal_previous_donations" toml:"tipgoal_previous_donations" yaml:"tipgoal_previous_donations"`
	TipgoalCurrency            string      `boil:"tipgoal_currency" json:"tipgoal_currency" toml:"tipgoal_currency" yaml:"tipgoal_currency"`
	TimeSinceFirstComment      null.Int64  `boil:"time_since_first_comment" json:"time_since_first_comment,omitempty" toml:"time_since_first_comment" yaml:"time_since_first_comment,omitempty"`
	BlockedWordsFuzzinessMatch null.Int64  `boil:"blocked_words_fuzziness_match" json:"blocked_words_fuzziness_match,omitempty" toml:"blocked_words_fuzziness_match" yaml:"blocked_words_fuzziness_match,omitempty"`

	R *creatorSettingR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L creatorSettingL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CreatorSettingColumns = struct {
	ID                         string
	CreatorChannelID           string
	CommentsEnabled            string
	MinTipAmountComment        string
	MinTipAmountSuperChat      string
	MutedWords                 string
	CreatedAt                  string
	UpdatedAt                  string
	SlowModeMinGap             string
	CurseJarAmount             string
	IsFiltersEnabled           string
	ChatOverlay                string
	ChatOverlayPosition        string
	ChatRemoveComment          string
	StickerOverlay             string
	StickerOverlayKeep         string
	StickerOverlayRemove       string
	ViewercountOverlay         string
	ViewercountOverlayPosition string
	ViewercountChatBot         string
	TipgoalOverlay             string
	TipgoalAmount              string
	TipgoalOverlayPosition     string
	TipgoalPreviousDonations   string
	TipgoalCurrency            string
	TimeSinceFirstComment      string
	BlockedWordsFuzzinessMatch string
}{
	ID:                         "id",
	CreatorChannelID:           "creator_channel_id",
	CommentsEnabled:            "comments_enabled",
	MinTipAmountComment:        "min_tip_amount_comment",
	MinTipAmountSuperChat:      "min_tip_amount_super_chat",
	MutedWords:                 "muted_words",
	CreatedAt:                  "created_at",
	UpdatedAt:                  "updated_at",
	SlowModeMinGap:             "slow_mode_min_gap",
	CurseJarAmount:             "curse_jar_amount",
	IsFiltersEnabled:           "is_filters_enabled",
	ChatOverlay:                "chat_overlay",
	ChatOverlayPosition:        "chat_overlay_position",
	ChatRemoveComment:          "chat_remove_comment",
	StickerOverlay:             "sticker_overlay",
	StickerOverlayKeep:         "sticker_overlay_keep",
	StickerOverlayRemove:       "sticker_overlay_remove",
	ViewercountOverlay:         "viewercount_overlay",
	ViewercountOverlayPosition: "viewercount_overlay_position",
	ViewercountChatBot:         "viewercount_chat_bot",
	TipgoalOverlay:             "tipgoal_overlay",
	TipgoalAmount:              "tipgoal_amount",
	TipgoalOverlayPosition:     "tipgoal_overlay_position",
	TipgoalPreviousDonations:   "tipgoal_previous_donations",
	TipgoalCurrency:            "tipgoal_currency",
	TimeSinceFirstComment:      "time_since_first_comment",
	BlockedWordsFuzzinessMatch: "blocked_words_fuzziness_match",
}

// Generated where

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var CreatorSettingWhere = struct {
	ID                         whereHelperuint64
	CreatorChannelID           whereHelperstring
	CommentsEnabled            whereHelpernull_Bool
	MinTipAmountComment        whereHelpernull_Uint64
	MinTipAmountSuperChat      whereHelpernull_Uint64
	MutedWords                 whereHelpernull_String
	CreatedAt                  whereHelpertime_Time
	UpdatedAt                  whereHelpertime_Time
	SlowModeMinGap             whereHelpernull_Uint64
	CurseJarAmount             whereHelpernull_Uint64
	IsFiltersEnabled           whereHelpernull_Bool
	ChatOverlay                whereHelperbool
	ChatOverlayPosition        whereHelperstring
	ChatRemoveComment          whereHelperint64
	StickerOverlay             whereHelperbool
	StickerOverlayKeep         whereHelperbool
	StickerOverlayRemove       whereHelperint64
	ViewercountOverlay         whereHelperbool
	ViewercountOverlayPosition whereHelperstring
	ViewercountChatBot         whereHelperbool
	TipgoalOverlay             whereHelperbool
	TipgoalAmount              whereHelperint64
	TipgoalOverlayPosition     whereHelperstring
	TipgoalPreviousDonations   whereHelperbool
	TipgoalCurrency            whereHelperstring
	TimeSinceFirstComment      whereHelpernull_Int64
	BlockedWordsFuzzinessMatch whereHelpernull_Int64
}{
	ID:                         whereHelperuint64{field: "`creator_setting`.`id`"},
	CreatorChannelID:           whereHelperstring{field: "`creator_setting`.`creator_channel_id`"},
	CommentsEnabled:            whereHelpernull_Bool{field: "`creator_setting`.`comments_enabled`"},
	MinTipAmountComment:        whereHelpernull_Uint64{field: "`creator_setting`.`min_tip_amount_comment`"},
	MinTipAmountSuperChat:      whereHelpernull_Uint64{field: "`creator_setting`.`min_tip_amount_super_chat`"},
	MutedWords:                 whereHelpernull_String{field: "`creator_setting`.`muted_words`"},
	CreatedAt:                  whereHelpertime_Time{field: "`creator_setting`.`created_at`"},
	UpdatedAt:                  whereHelpertime_Time{field: "`creator_setting`.`updated_at`"},
	SlowModeMinGap:             whereHelpernull_Uint64{field: "`creator_setting`.`slow_mode_min_gap`"},
	CurseJarAmount:             whereHelpernull_Uint64{field: "`creator_setting`.`curse_jar_amount`"},
	IsFiltersEnabled:           whereHelpernull_Bool{field: "`creator_setting`.`is_filters_enabled`"},
	ChatOverlay:                whereHelperbool{field: "`creator_setting`.`chat_overlay`"},
	ChatOverlayPosition:        whereHelperstring{field: "`creator_setting`.`chat_overlay_position`"},
	ChatRemoveComment:          whereHelperint64{field: "`creator_setting`.`chat_remove_comment`"},
	StickerOverlay:             whereHelperbool{field: "`creator_setting`.`sticker_overlay`"},
	StickerOverlayKeep:         whereHelperbool{field: "`creator_setting`.`sticker_overlay_keep`"},
	StickerOverlayRemove:       whereHelperint64{field: "`creator_setting`.`sticker_overlay_remove`"},
	ViewercountOverlay:         whereHelperbool{field: "`creator_setting`.`viewercount_overlay`"},
	ViewercountOverlayPosition: whereHelperstring{field: "`creator_setting`.`viewercount_overlay_position`"},
	ViewercountChatBot:         whereHelperbool{field: "`creator_setting`.`viewercount_chat_bot`"},
	TipgoalOverlay:             whereHelperbool{field: "`creator_setting`.`tipgoal_overlay`"},
	TipgoalAmount:              whereHelperint64{field: "`creator_setting`.`tipgoal_amount`"},
	TipgoalOverlayPosition:     whereHelperstring{field: "`creator_setting`.`tipgoal_overlay_position`"},
	TipgoalPreviousDonations:   whereHelperbool{field: "`creator_setting`.`tipgoal_previous_donations`"},
	TipgoalCurrency:            whereHelperstring{field: "`creator_setting`.`tipgoal_currency`"},
	TimeSinceFirstComment:      whereHelpernull_Int64{field: "`creator_setting`.`time_since_first_comment`"},
	BlockedWordsFuzzinessMatch: whereHelpernull_Int64{field: "`creator_setting`.`blocked_words_fuzziness_match`"},
}

// CreatorSettingRels is where relationship names are stored.
var CreatorSettingRels = struct {
	CreatorChannel string
}{
	CreatorChannel: "CreatorChannel",
}

// creatorSettingR is where relationships are stored.
type creatorSettingR struct {
	CreatorChannel *Channel
}

// NewStruct creates a new relationship struct
func (*creatorSettingR) NewStruct() *creatorSettingR {
	return &creatorSettingR{}
}

// creatorSettingL is where Load methods for each relationship are stored.
type creatorSettingL struct{}

var (
	creatorSettingAllColumns            = []string{"id", "creator_channel_id", "comments_enabled", "min_tip_amount_comment", "min_tip_amount_super_chat", "muted_words", "created_at", "updated_at", "slow_mode_min_gap", "curse_jar_amount", "is_filters_enabled", "chat_overlay", "chat_overlay_position", "chat_remove_comment", "sticker_overlay", "sticker_overlay_keep", "sticker_overlay_remove", "viewercount_overlay", "viewercount_overlay_position", "viewercount_chat_bot", "tipgoal_overlay", "tipgoal_amount", "tipgoal_overlay_position", "tipgoal_previous_donations", "tipgoal_currency", "time_since_first_comment", "blocked_words_fuzziness_match"}
	creatorSettingColumnsWithoutDefault = []string{"creator_channel_id", "min_tip_amount_comment", "min_tip_amount_super_chat", "muted_words", "slow_mode_min_gap", "curse_jar_amount", "is_filters_enabled", "time_since_first_comment", "blocked_words_fuzziness_match"}
	creatorSettingColumnsWithDefault    = []string{"id", "comments_enabled", "created_at", "updated_at", "chat_overlay", "chat_overlay_position", "chat_remove_comment", "sticker_overlay", "sticker_overlay_keep", "sticker_overlay_remove", "viewercount_overlay", "viewercount_overlay_position", "viewercount_chat_bot", "tipgoal_overlay", "tipgoal_amount", "tipgoal_overlay_position", "tipgoal_previous_donations", "tipgoal_currency"}
	creatorSettingPrimaryKeyColumns     = []string{"id"}
)

type (
	// CreatorSettingSlice is an alias for a slice of pointers to CreatorSetting.
	// This should generally be used opposed to []CreatorSetting.
	CreatorSettingSlice []*CreatorSetting

	creatorSettingQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	creatorSettingType                 = reflect.TypeOf(&CreatorSetting{})
	creatorSettingMapping              = queries.MakeStructMapping(creatorSettingType)
	creatorSettingPrimaryKeyMapping, _ = queries.BindMapping(creatorSettingType, creatorSettingMapping, creatorSettingPrimaryKeyColumns)
	creatorSettingInsertCacheMut       sync.RWMutex
	creatorSettingInsertCache          = make(map[string]insertCache)
	creatorSettingUpdateCacheMut       sync.RWMutex
	creatorSettingUpdateCache          = make(map[string]updateCache)
	creatorSettingUpsertCacheMut       sync.RWMutex
	creatorSettingUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single creatorSetting record from the query.
func (q creatorSettingQuery) One(exec boil.Executor) (*CreatorSetting, error) {
	o := &CreatorSetting{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for creator_setting")
	}

	return o, nil
}

// All returns all CreatorSetting records from the query.
func (q creatorSettingQuery) All(exec boil.Executor) (CreatorSettingSlice, error) {
	var o []*CreatorSetting

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to CreatorSetting slice")
	}

	return o, nil
}

// Count returns the count of all CreatorSetting records in the query.
func (q creatorSettingQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count creator_setting rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q creatorSettingQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if creator_setting exists")
	}

	return count > 0, nil
}

// CreatorChannel pointed to by the foreign key.
func (o *CreatorSetting) CreatorChannel(mods ...qm.QueryMod) channelQuery {
	queryMods := []qm.QueryMod{
		qm.Where("claim_id=?", o.CreatorChannelID),
	}

	queryMods = append(queryMods, mods...)

	query := Channels(queryMods...)
	queries.SetFrom(query.Query, "`channel`")

	return query
}

// LoadCreatorChannel allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (creatorSettingL) LoadCreatorChannel(e boil.Executor, singular bool, maybeCreatorSetting interface{}, mods queries.Applicator) error {
	var slice []*CreatorSetting
	var object *CreatorSetting

	if singular {
		object = maybeCreatorSetting.(*CreatorSetting)
	} else {
		slice = *maybeCreatorSetting.(*[]*CreatorSetting)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &creatorSettingR{}
		}
		args = append(args, object.CreatorChannelID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &creatorSettingR{}
			}

			for _, a := range args {
				if a == obj.CreatorChannelID {
					continue Outer
				}
			}

			args = append(args, obj.CreatorChannelID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`channel`), qm.WhereIn(`claim_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Channel")
	}

	var resultSlice []*Channel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Channel")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for channel")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for channel")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CreatorChannel = foreign
		if foreign.R == nil {
			foreign.R = &channelR{}
		}
		foreign.R.CreatorChannelCreatorSettings = append(foreign.R.CreatorChannelCreatorSettings, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CreatorChannelID == foreign.ClaimID {
				local.R.CreatorChannel = foreign
				if foreign.R == nil {
					foreign.R = &channelR{}
				}
				foreign.R.CreatorChannelCreatorSettings = append(foreign.R.CreatorChannelCreatorSettings, local)
				break
			}
		}
	}

	return nil
}

// SetCreatorChannel of the creatorSetting to the related item.
// Sets o.R.CreatorChannel to related.
// Adds o to related.R.CreatorChannelCreatorSettings.
func (o *CreatorSetting) SetCreatorChannel(exec boil.Executor, insert bool, related *Channel) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `creator_setting` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"creator_channel_id"}),
		strmangle.WhereClause("`", "`", 0, creatorSettingPrimaryKeyColumns),
	)
	values := []interface{}{related.ClaimID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CreatorChannelID = related.ClaimID
	if o.R == nil {
		o.R = &creatorSettingR{
			CreatorChannel: related,
		}
	} else {
		o.R.CreatorChannel = related
	}

	if related.R == nil {
		related.R = &channelR{
			CreatorChannelCreatorSettings: CreatorSettingSlice{o},
		}
	} else {
		related.R.CreatorChannelCreatorSettings = append(related.R.CreatorChannelCreatorSettings, o)
	}

	return nil
}

// CreatorSettings retrieves all the records using an executor.
func CreatorSettings(mods ...qm.QueryMod) creatorSettingQuery {
	mods = append(mods, qm.From("`creator_setting`"))
	return creatorSettingQuery{NewQuery(mods...)}
}

// FindCreatorSetting retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCreatorSetting(exec boil.Executor, iD uint64, selectCols ...string) (*CreatorSetting, error) {
	creatorSettingObj := &CreatorSetting{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `creator_setting` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, creatorSettingObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from creator_setting")
	}

	return creatorSettingObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CreatorSetting) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no creator_setting provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(creatorSettingColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	creatorSettingInsertCacheMut.RLock()
	cache, cached := creatorSettingInsertCache[key]
	creatorSettingInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			creatorSettingAllColumns,
			creatorSettingColumnsWithDefault,
			creatorSettingColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(creatorSettingType, creatorSettingMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(creatorSettingType, creatorSettingMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `creator_setting` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `creator_setting` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `creator_setting` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, creatorSettingPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into creator_setting")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == creatorSettingMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRow(cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for creator_setting")
	}

CacheNoHooks:
	if !cached {
		creatorSettingInsertCacheMut.Lock()
		creatorSettingInsertCache[key] = cache
		creatorSettingInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the CreatorSetting.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CreatorSetting) Update(exec boil.Executor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	creatorSettingUpdateCacheMut.RLock()
	cache, cached := creatorSettingUpdateCache[key]
	creatorSettingUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			creatorSettingAllColumns,
			creatorSettingPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return errors.New("model: unable to update creator_setting, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `creator_setting` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, creatorSettingPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(creatorSettingType, creatorSettingMapping, append(wl, creatorSettingPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err = exec.Exec(cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update creator_setting row")
	}

	if !cached {
		creatorSettingUpdateCacheMut.Lock()
		creatorSettingUpdateCache[key] = cache
		creatorSettingUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q creatorSettingQuery) UpdateAll(exec boil.Executor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all for creator_setting")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CreatorSettingSlice) UpdateAll(exec boil.Executor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), creatorSettingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `creator_setting` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, creatorSettingPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all in creatorSetting slice")
	}

	return nil
}

var mySQLCreatorSettingUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CreatorSetting) Upsert(exec boil.Executor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no creator_setting provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(creatorSettingColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCreatorSettingUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	creatorSettingUpsertCacheMut.RLock()
	cache, cached := creatorSettingUpsertCache[key]
	creatorSettingUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			creatorSettingAllColumns,
			creatorSettingColumnsWithDefault,
			creatorSettingColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			creatorSettingAllColumns,
			creatorSettingPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("model: unable to upsert creator_setting, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "creator_setting", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `creator_setting` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(creatorSettingType, creatorSettingMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(creatorSettingType, creatorSettingMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for creator_setting")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == creatorSettingMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(creatorSettingType, creatorSettingMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for creator_setting")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRow(cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for creator_setting")
	}

CacheNoHooks:
	if !cached {
		creatorSettingUpsertCacheMut.Lock()
		creatorSettingUpsertCache[key] = cache
		creatorSettingUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single CreatorSetting record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CreatorSetting) Delete(exec boil.Executor) error {
	if o == nil {
		return errors.New("model: no CreatorSetting provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), creatorSettingPrimaryKeyMapping)
	sql := "DELETE FROM `creator_setting` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete from creator_setting")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q creatorSettingQuery) DeleteAll(exec boil.Executor) error {
	if q.Query == nil {
		return errors.New("model: no creatorSettingQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from creator_setting")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CreatorSettingSlice) DeleteAll(exec boil.Executor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), creatorSettingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `creator_setting` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, creatorSettingPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from creatorSetting slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CreatorSetting) Reload(exec boil.Executor) error {
	ret, err := FindCreatorSetting(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CreatorSettingSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CreatorSettingSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), creatorSettingPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `creator_setting`.* FROM `creator_setting` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, creatorSettingPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in CreatorSettingSlice")
	}

	*o = slice

	return nil
}

// CreatorSettingExists checks if the CreatorSetting row exists.
func CreatorSettingExists(exec boil.Executor, iD uint64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `creator_setting` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if creator_setting exists")
	}

	return exists, nil
}
