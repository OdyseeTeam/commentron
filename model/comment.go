// Code generated by SQLBoiler 4.19.7 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Comment is an object representing the database table.
type Comment struct {
	CommentID        string      `boil:"comment_id" json:"comment_id" toml:"comment_id" yaml:"comment_id"`
	LbryClaimID      string      `boil:"lbry_claim_id" json:"lbry_claim_id" toml:"lbry_claim_id" yaml:"lbry_claim_id"`
	ChannelID        null.String `boil:"channel_id" json:"channel_id,omitempty" toml:"channel_id" yaml:"channel_id,omitempty"`
	Body             string      `boil:"body" json:"body" toml:"body" yaml:"body"`
	ParentID         null.String `boil:"parent_id" json:"parent_id,omitempty" toml:"parent_id" yaml:"parent_id,omitempty"`
	Signature        null.String `boil:"signature" json:"signature,omitempty" toml:"signature" yaml:"signature,omitempty"`
	Signingts        null.String `boil:"signingts" json:"signingts,omitempty" toml:"signingts" yaml:"signingts,omitempty"`
	Timestamp        int         `boil:"timestamp" json:"timestamp" toml:"timestamp" yaml:"timestamp"`
	IsHidden         null.Bool   `boil:"is_hidden" json:"is_hidden,omitempty" toml:"is_hidden" yaml:"is_hidden,omitempty"`
	IsPinned         bool        `boil:"is_pinned" json:"is_pinned" toml:"is_pinned" yaml:"is_pinned"`
	IsFlagged        bool        `boil:"is_flagged" json:"is_flagged" toml:"is_flagged" yaml:"is_flagged"`
	Amount           null.Uint64 `boil:"amount" json:"amount,omitempty" toml:"amount" yaml:"amount,omitempty"`
	TXID             null.String `boil:"tx_id" json:"tx_id,omitempty" toml:"tx_id" yaml:"tx_id,omitempty"`
	PopularityScore  null.Int    `boil:"popularity_score" json:"popularity_score,omitempty" toml:"popularity_score" yaml:"popularity_score,omitempty"`
	ControversyScore null.Int    `boil:"controversy_score" json:"controversy_score,omitempty" toml:"controversy_score" yaml:"controversy_score,omitempty"`
	IsFiat           bool        `boil:"is_fiat" json:"is_fiat" toml:"is_fiat" yaml:"is_fiat"`
	Currency         null.String `boil:"currency" json:"currency,omitempty" toml:"currency" yaml:"currency,omitempty"`
	IsProtected      bool        `boil:"is_protected" json:"is_protected" toml:"is_protected" yaml:"is_protected"`
	DeletedAt        null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *commentR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L commentL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CommentColumns = struct {
	CommentID        string
	LbryClaimID      string
	ChannelID        string
	Body             string
	ParentID         string
	Signature        string
	Signingts        string
	Timestamp        string
	IsHidden         string
	IsPinned         string
	IsFlagged        string
	Amount           string
	TXID             string
	PopularityScore  string
	ControversyScore string
	IsFiat           string
	Currency         string
	IsProtected      string
	DeletedAt        string
}{
	CommentID:        "comment_id",
	LbryClaimID:      "lbry_claim_id",
	ChannelID:        "channel_id",
	Body:             "body",
	ParentID:         "parent_id",
	Signature:        "signature",
	Signingts:        "signingts",
	Timestamp:        "timestamp",
	IsHidden:         "is_hidden",
	IsPinned:         "is_pinned",
	IsFlagged:        "is_flagged",
	Amount:           "amount",
	TXID:             "tx_id",
	PopularityScore:  "popularity_score",
	ControversyScore: "controversy_score",
	IsFiat:           "is_fiat",
	Currency:         "currency",
	IsProtected:      "is_protected",
	DeletedAt:        "deleted_at",
}

var CommentTableColumns = struct {
	CommentID        string
	LbryClaimID      string
	ChannelID        string
	Body             string
	ParentID         string
	Signature        string
	Signingts        string
	Timestamp        string
	IsHidden         string
	IsPinned         string
	IsFlagged        string
	Amount           string
	TXID             string
	PopularityScore  string
	ControversyScore string
	IsFiat           string
	Currency         string
	IsProtected      string
	DeletedAt        string
}{
	CommentID:        "comment.comment_id",
	LbryClaimID:      "comment.lbry_claim_id",
	ChannelID:        "comment.channel_id",
	Body:             "comment.body",
	ParentID:         "comment.parent_id",
	Signature:        "comment.signature",
	Signingts:        "comment.signingts",
	Timestamp:        "comment.timestamp",
	IsHidden:         "comment.is_hidden",
	IsPinned:         "comment.is_pinned",
	IsFlagged:        "comment.is_flagged",
	Amount:           "comment.amount",
	TXID:             "comment.tx_id",
	PopularityScore:  "comment.popularity_score",
	ControversyScore: "comment.controversy_score",
	IsFiat:           "comment.is_fiat",
	Currency:         "comment.currency",
	IsProtected:      "comment.is_protected",
	DeletedAt:        "comment.deleted_at",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]any, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]any, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var CommentWhere = struct {
	CommentID        whereHelperstring
	LbryClaimID      whereHelperstring
	ChannelID        whereHelpernull_String
	Body             whereHelperstring
	ParentID         whereHelpernull_String
	Signature        whereHelpernull_String
	Signingts        whereHelpernull_String
	Timestamp        whereHelperint
	IsHidden         whereHelpernull_Bool
	IsPinned         whereHelperbool
	IsFlagged        whereHelperbool
	Amount           whereHelpernull_Uint64
	TXID             whereHelpernull_String
	PopularityScore  whereHelpernull_Int
	ControversyScore whereHelpernull_Int
	IsFiat           whereHelperbool
	Currency         whereHelpernull_String
	IsProtected      whereHelperbool
	DeletedAt        whereHelpernull_Time
}{
	CommentID:        whereHelperstring{field: "`comment`.`comment_id`"},
	LbryClaimID:      whereHelperstring{field: "`comment`.`lbry_claim_id`"},
	ChannelID:        whereHelpernull_String{field: "`comment`.`channel_id`"},
	Body:             whereHelperstring{field: "`comment`.`body`"},
	ParentID:         whereHelpernull_String{field: "`comment`.`parent_id`"},
	Signature:        whereHelpernull_String{field: "`comment`.`signature`"},
	Signingts:        whereHelpernull_String{field: "`comment`.`signingts`"},
	Timestamp:        whereHelperint{field: "`comment`.`timestamp`"},
	IsHidden:         whereHelpernull_Bool{field: "`comment`.`is_hidden`"},
	IsPinned:         whereHelperbool{field: "`comment`.`is_pinned`"},
	IsFlagged:        whereHelperbool{field: "`comment`.`is_flagged`"},
	Amount:           whereHelpernull_Uint64{field: "`comment`.`amount`"},
	TXID:             whereHelpernull_String{field: "`comment`.`tx_id`"},
	PopularityScore:  whereHelpernull_Int{field: "`comment`.`popularity_score`"},
	ControversyScore: whereHelpernull_Int{field: "`comment`.`controversy_score`"},
	IsFiat:           whereHelperbool{field: "`comment`.`is_fiat`"},
	Currency:         whereHelpernull_String{field: "`comment`.`currency`"},
	IsProtected:      whereHelperbool{field: "`comment`.`is_protected`"},
	DeletedAt:        whereHelpernull_Time{field: "`comment`.`deleted_at`"},
}

// CommentRels is where relationship names are stored.
var CommentRels = struct {
	Channel                        string
	Parent                         string
	CommentClassification          string
	OffendingCommentBlockedEntries string
	ParentComments                 string
	Reactions                      string
}{
	Channel:                        "Channel",
	Parent:                         "Parent",
	CommentClassification:          "CommentClassification",
	OffendingCommentBlockedEntries: "OffendingCommentBlockedEntries",
	ParentComments:                 "ParentComments",
	Reactions:                      "Reactions",
}

// commentR is where relationships are stored.
type commentR struct {
	Channel                        *Channel               `boil:"Channel" json:"Channel" toml:"Channel" yaml:"Channel"`
	Parent                         *Comment               `boil:"Parent" json:"Parent" toml:"Parent" yaml:"Parent"`
	CommentClassification          *CommentClassification `boil:"CommentClassification" json:"CommentClassification" toml:"CommentClassification" yaml:"CommentClassification"`
	OffendingCommentBlockedEntries BlockedEntrySlice      `boil:"OffendingCommentBlockedEntries" json:"OffendingCommentBlockedEntries" toml:"OffendingCommentBlockedEntries" yaml:"OffendingCommentBlockedEntries"`
	ParentComments                 CommentSlice           `boil:"ParentComments" json:"ParentComments" toml:"ParentComments" yaml:"ParentComments"`
	Reactions                      ReactionSlice          `boil:"Reactions" json:"Reactions" toml:"Reactions" yaml:"Reactions"`
}

// NewStruct creates a new relationship struct
func (*commentR) NewStruct() *commentR {
	return &commentR{}
}

func (o *Comment) GetChannel() *Channel {
	if o == nil {
		return nil
	}

	return o.R.GetChannel()
}

func (r *commentR) GetChannel() *Channel {
	if r == nil {
		return nil
	}

	return r.Channel
}

func (o *Comment) GetParent() *Comment {
	if o == nil {
		return nil
	}

	return o.R.GetParent()
}

func (r *commentR) GetParent() *Comment {
	if r == nil {
		return nil
	}

	return r.Parent
}

func (o *Comment) GetCommentClassification() *CommentClassification {
	if o == nil {
		return nil
	}

	return o.R.GetCommentClassification()
}

func (r *commentR) GetCommentClassification() *CommentClassification {
	if r == nil {
		return nil
	}

	return r.CommentClassification
}

func (o *Comment) GetOffendingCommentBlockedEntries() BlockedEntrySlice {
	if o == nil {
		return nil
	}

	return o.R.GetOffendingCommentBlockedEntries()
}

func (r *commentR) GetOffendingCommentBlockedEntries() BlockedEntrySlice {
	if r == nil {
		return nil
	}

	return r.OffendingCommentBlockedEntries
}

func (o *Comment) GetParentComments() CommentSlice {
	if o == nil {
		return nil
	}

	return o.R.GetParentComments()
}

func (r *commentR) GetParentComments() CommentSlice {
	if r == nil {
		return nil
	}

	return r.ParentComments
}

func (o *Comment) GetReactions() ReactionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetReactions()
}

func (r *commentR) GetReactions() ReactionSlice {
	if r == nil {
		return nil
	}

	return r.Reactions
}

// commentL is where Load methods for each relationship are stored.
type commentL struct{}

var (
	commentAllColumns            = []string{"comment_id", "lbry_claim_id", "channel_id", "body", "parent_id", "signature", "signingts", "timestamp", "is_hidden", "is_pinned", "is_flagged", "amount", "tx_id", "popularity_score", "controversy_score", "is_fiat", "currency", "is_protected", "deleted_at"}
	commentColumnsWithoutDefault = []string{"comment_id", "lbry_claim_id", "channel_id", "body", "parent_id", "signature", "signingts", "timestamp", "amount", "tx_id", "popularity_score", "controversy_score", "currency", "deleted_at"}
	commentColumnsWithDefault    = []string{"is_hidden", "is_pinned", "is_flagged", "is_fiat", "is_protected"}
	commentPrimaryKeyColumns     = []string{"comment_id"}
	commentGeneratedColumns      = []string{}
)

type (
	// CommentSlice is an alias for a slice of pointers to Comment.
	// This should almost always be used instead of []Comment.
	CommentSlice []*Comment

	commentQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	commentType                 = reflect.TypeOf(&Comment{})
	commentMapping              = queries.MakeStructMapping(commentType)
	commentPrimaryKeyMapping, _ = queries.BindMapping(commentType, commentMapping, commentPrimaryKeyColumns)
	commentInsertCacheMut       sync.RWMutex
	commentInsertCache          = make(map[string]insertCache)
	commentUpdateCacheMut       sync.RWMutex
	commentUpdateCache          = make(map[string]updateCache)
	commentUpsertCacheMut       sync.RWMutex
	commentUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single comment record from the query.
func (q commentQuery) One(exec boil.Executor) (*Comment, error) {
	o := &Comment{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for comment")
	}

	return o, nil
}

// All returns all Comment records from the query.
func (q commentQuery) All(exec boil.Executor) (CommentSlice, error) {
	var o []*Comment

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to Comment slice")
	}

	return o, nil
}

// Count returns the count of all Comment records in the query.
func (q commentQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count comment rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q commentQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if comment exists")
	}

	return count > 0, nil
}

// Channel pointed to by the foreign key.
func (o *Comment) Channel(mods ...qm.QueryMod) channelQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`claim_id` = ?", o.ChannelID),
	}

	queryMods = append(queryMods, mods...)

	return Channels(queryMods...)
}

// Parent pointed to by the foreign key.
func (o *Comment) Parent(mods ...qm.QueryMod) commentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`comment_id` = ?", o.ParentID),
	}

	queryMods = append(queryMods, mods...)

	return Comments(queryMods...)
}

// CommentClassification pointed to by the foreign key.
func (o *Comment) CommentClassification(mods ...qm.QueryMod) commentClassificationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`comment_id` = ?", o.CommentID),
	}

	queryMods = append(queryMods, mods...)

	return CommentClassifications(queryMods...)
}

// OffendingCommentBlockedEntries retrieves all the blocked_entry's BlockedEntries with an executor via offending_comment_id column.
func (o *Comment) OffendingCommentBlockedEntries(mods ...qm.QueryMod) blockedEntryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`blocked_entry`.`offending_comment_id`=?", o.CommentID),
	)

	return BlockedEntries(queryMods...)
}

// ParentComments retrieves all the comment's Comments with an executor via parent_id column.
func (o *Comment) ParentComments(mods ...qm.QueryMod) commentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`comment`.`parent_id`=?", o.CommentID),
	)

	return Comments(queryMods...)
}

// Reactions retrieves all the reaction's Reactions with an executor.
func (o *Comment) Reactions(mods ...qm.QueryMod) reactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`reaction`.`comment_id`=?", o.CommentID),
	)

	return Reactions(queryMods...)
}

// LoadChannel allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (commentL) LoadChannel(e boil.Executor, singular bool, maybeComment any, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		var ok bool
		object, ok = maybeComment.(*Comment)
		if !ok {
			object = new(Comment)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeComment))
			}
		}
	} else {
		s, ok := maybeComment.(*[]*Comment)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeComment))
			}
		}
	}

	args := make(map[any]struct{})
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		if !queries.IsNil(object.ChannelID) {
			args[object.ChannelID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}

			if !queries.IsNil(obj.ChannelID) {
				args[obj.ChannelID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]any, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`channel`),
		qm.WhereIn(`channel.claim_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Channel")
	}

	var resultSlice []*Channel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Channel")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for channel")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for channel")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Channel = foreign
		if foreign.R == nil {
			foreign.R = &channelR{}
		}
		foreign.R.Comments = append(foreign.R.Comments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ChannelID, foreign.ClaimID) {
				local.R.Channel = foreign
				if foreign.R == nil {
					foreign.R = &channelR{}
				}
				foreign.R.Comments = append(foreign.R.Comments, local)
				break
			}
		}
	}

	return nil
}

// LoadParent allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (commentL) LoadParent(e boil.Executor, singular bool, maybeComment any, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		var ok bool
		object, ok = maybeComment.(*Comment)
		if !ok {
			object = new(Comment)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeComment))
			}
		}
	} else {
		s, ok := maybeComment.(*[]*Comment)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeComment))
			}
		}
	}

	args := make(map[any]struct{})
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		if !queries.IsNil(object.ParentID) {
			args[object.ParentID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}

			if !queries.IsNil(obj.ParentID) {
				args[obj.ParentID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]any, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`comment`),
		qm.WhereIn(`comment.comment_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`comment.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Comment")
	}

	var resultSlice []*Comment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Comment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for comment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Parent = foreign
		if foreign.R == nil {
			foreign.R = &commentR{}
		}
		foreign.R.ParentComments = append(foreign.R.ParentComments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ParentID, foreign.CommentID) {
				local.R.Parent = foreign
				if foreign.R == nil {
					foreign.R = &commentR{}
				}
				foreign.R.ParentComments = append(foreign.R.ParentComments, local)
				break
			}
		}
	}

	return nil
}

// LoadCommentClassification allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (commentL) LoadCommentClassification(e boil.Executor, singular bool, maybeComment any, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		var ok bool
		object, ok = maybeComment.(*Comment)
		if !ok {
			object = new(Comment)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeComment))
			}
		}
	} else {
		s, ok := maybeComment.(*[]*Comment)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeComment))
			}
		}
	}

	args := make(map[any]struct{})
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		args[object.CommentID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}

			args[obj.CommentID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]any, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`comment_classification`),
		qm.WhereIn(`comment_classification.comment_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CommentClassification")
	}

	var resultSlice []*CommentClassification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CommentClassification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for comment_classification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment_classification")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CommentClassification = foreign
		if foreign.R == nil {
			foreign.R = &commentClassificationR{}
		}
		foreign.R.Comment = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CommentID == foreign.CommentID {
				local.R.CommentClassification = foreign
				if foreign.R == nil {
					foreign.R = &commentClassificationR{}
				}
				foreign.R.Comment = local
				break
			}
		}
	}

	return nil
}

// LoadOffendingCommentBlockedEntries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (commentL) LoadOffendingCommentBlockedEntries(e boil.Executor, singular bool, maybeComment any, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		var ok bool
		object, ok = maybeComment.(*Comment)
		if !ok {
			object = new(Comment)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeComment))
			}
		}
	} else {
		s, ok := maybeComment.(*[]*Comment)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeComment))
			}
		}
	}

	args := make(map[any]struct{})
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		args[object.CommentID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}
			args[obj.CommentID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]any, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`blocked_entry`),
		qm.WhereIn(`blocked_entry.offending_comment_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load blocked_entry")
	}

	var resultSlice []*BlockedEntry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice blocked_entry")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on blocked_entry")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blocked_entry")
	}

	if singular {
		object.R.OffendingCommentBlockedEntries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &blockedEntryR{}
			}
			foreign.R.OffendingComment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.CommentID, foreign.OffendingCommentID) {
				local.R.OffendingCommentBlockedEntries = append(local.R.OffendingCommentBlockedEntries, foreign)
				if foreign.R == nil {
					foreign.R = &blockedEntryR{}
				}
				foreign.R.OffendingComment = local
				break
			}
		}
	}

	return nil
}

// LoadParentComments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (commentL) LoadParentComments(e boil.Executor, singular bool, maybeComment any, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		var ok bool
		object, ok = maybeComment.(*Comment)
		if !ok {
			object = new(Comment)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeComment))
			}
		}
	} else {
		s, ok := maybeComment.(*[]*Comment)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeComment))
			}
		}
	}

	args := make(map[any]struct{})
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		args[object.CommentID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}
			args[obj.CommentID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]any, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`comment`),
		qm.WhereIn(`comment.parent_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`comment.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load comment")
	}

	var resultSlice []*Comment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice comment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on comment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment")
	}

	if singular {
		object.R.ParentComments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commentR{}
			}
			foreign.R.Parent = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.CommentID, foreign.ParentID) {
				local.R.ParentComments = append(local.R.ParentComments, foreign)
				if foreign.R == nil {
					foreign.R = &commentR{}
				}
				foreign.R.Parent = local
				break
			}
		}
	}

	return nil
}

// LoadReactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (commentL) LoadReactions(e boil.Executor, singular bool, maybeComment any, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		var ok bool
		object, ok = maybeComment.(*Comment)
		if !ok {
			object = new(Comment)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeComment))
			}
		}
	} else {
		s, ok := maybeComment.(*[]*Comment)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeComment)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeComment))
			}
		}
	}

	args := make(map[any]struct{})
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		args[object.CommentID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}
			args[obj.CommentID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]any, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`reaction`),
		qm.WhereIn(`reaction.comment_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load reaction")
	}

	var resultSlice []*Reaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice reaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on reaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for reaction")
	}

	if singular {
		object.R.Reactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &reactionR{}
			}
			foreign.R.Comment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.CommentID == foreign.CommentID {
				local.R.Reactions = append(local.R.Reactions, foreign)
				if foreign.R == nil {
					foreign.R = &reactionR{}
				}
				foreign.R.Comment = local
				break
			}
		}
	}

	return nil
}

// SetChannel of the comment to the related item.
// Sets o.R.Channel to related.
// Adds o to related.R.Comments.
func (o *Comment) SetChannel(exec boil.Executor, insert bool, related *Channel) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `comment` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"channel_id"}),
		strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
	)
	values := []any{related.ClaimID, o.CommentID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ChannelID, related.ClaimID)
	if o.R == nil {
		o.R = &commentR{
			Channel: related,
		}
	} else {
		o.R.Channel = related
	}

	if related.R == nil {
		related.R = &channelR{
			Comments: CommentSlice{o},
		}
	} else {
		related.R.Comments = append(related.R.Comments, o)
	}

	return nil
}

// RemoveChannel relationship.
// Sets o.R.Channel to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Comment) RemoveChannel(exec boil.Executor, related *Channel) error {
	var err error

	queries.SetScanner(&o.ChannelID, nil)
	if err = o.Update(exec, boil.Whitelist("channel_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Channel = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Comments {
		if queries.Equal(o.ChannelID, ri.ChannelID) {
			continue
		}

		ln := len(related.R.Comments)
		if ln > 1 && i < ln-1 {
			related.R.Comments[i] = related.R.Comments[ln-1]
		}
		related.R.Comments = related.R.Comments[:ln-1]
		break
	}
	return nil
}

// SetParent of the comment to the related item.
// Sets o.R.Parent to related.
// Adds o to related.R.ParentComments.
func (o *Comment) SetParent(exec boil.Executor, insert bool, related *Comment) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `comment` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"parent_id"}),
		strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
	)
	values := []any{related.CommentID, o.CommentID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ParentID, related.CommentID)
	if o.R == nil {
		o.R = &commentR{
			Parent: related,
		}
	} else {
		o.R.Parent = related
	}

	if related.R == nil {
		related.R = &commentR{
			ParentComments: CommentSlice{o},
		}
	} else {
		related.R.ParentComments = append(related.R.ParentComments, o)
	}

	return nil
}

// RemoveParent relationship.
// Sets o.R.Parent to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Comment) RemoveParent(exec boil.Executor, related *Comment) error {
	var err error

	queries.SetScanner(&o.ParentID, nil)
	if err = o.Update(exec, boil.Whitelist("parent_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Parent = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ParentComments {
		if queries.Equal(o.ParentID, ri.ParentID) {
			continue
		}

		ln := len(related.R.ParentComments)
		if ln > 1 && i < ln-1 {
			related.R.ParentComments[i] = related.R.ParentComments[ln-1]
		}
		related.R.ParentComments = related.R.ParentComments[:ln-1]
		break
	}
	return nil
}

// SetCommentClassification of the comment to the related item.
// Sets o.R.CommentClassification to related.
// Adds o to related.R.Comment.
func (o *Comment) SetCommentClassification(exec boil.Executor, insert bool, related *CommentClassification) error {
	var err error

	if insert {
		related.CommentID = o.CommentID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `comment_classification` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"comment_id"}),
			strmangle.WhereClause("`", "`", 0, commentClassificationPrimaryKeyColumns),
		)
		values := []any{o.CommentID, related.CommentID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.CommentID = o.CommentID
	}

	if o.R == nil {
		o.R = &commentR{
			CommentClassification: related,
		}
	} else {
		o.R.CommentClassification = related
	}

	if related.R == nil {
		related.R = &commentClassificationR{
			Comment: o,
		}
	} else {
		related.R.Comment = o
	}
	return nil
}

// AddOffendingCommentBlockedEntries adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.OffendingCommentBlockedEntries.
// Sets related.R.OffendingComment appropriately.
func (o *Comment) AddOffendingCommentBlockedEntries(exec boil.Executor, insert bool, related ...*BlockedEntry) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OffendingCommentID, o.CommentID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `blocked_entry` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"offending_comment_id"}),
				strmangle.WhereClause("`", "`", 0, blockedEntryPrimaryKeyColumns),
			)
			values := []any{o.CommentID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OffendingCommentID, o.CommentID)
		}
	}

	if o.R == nil {
		o.R = &commentR{
			OffendingCommentBlockedEntries: related,
		}
	} else {
		o.R.OffendingCommentBlockedEntries = append(o.R.OffendingCommentBlockedEntries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &blockedEntryR{
				OffendingComment: o,
			}
		} else {
			rel.R.OffendingComment = o
		}
	}
	return nil
}

// SetOffendingCommentBlockedEntries removes all previously related items of the
// comment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OffendingComment's OffendingCommentBlockedEntries accordingly.
// Replaces o.R.OffendingCommentBlockedEntries with related.
// Sets related.R.OffendingComment's OffendingCommentBlockedEntries accordingly.
func (o *Comment) SetOffendingCommentBlockedEntries(exec boil.Executor, insert bool, related ...*BlockedEntry) error {
	query := "update `blocked_entry` set `offending_comment_id` = null where `offending_comment_id` = ?"
	values := []any{o.CommentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OffendingCommentBlockedEntries {
			queries.SetScanner(&rel.OffendingCommentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.OffendingComment = nil
		}
		o.R.OffendingCommentBlockedEntries = nil
	}

	return o.AddOffendingCommentBlockedEntries(exec, insert, related...)
}

// RemoveOffendingCommentBlockedEntries relationships from objects passed in.
// Removes related items from R.OffendingCommentBlockedEntries (uses pointer comparison, removal does not keep order)
// Sets related.R.OffendingComment.
func (o *Comment) RemoveOffendingCommentBlockedEntries(exec boil.Executor, related ...*BlockedEntry) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OffendingCommentID, nil)
		if rel.R != nil {
			rel.R.OffendingComment = nil
		}
		if err = rel.Update(exec, boil.Whitelist("offending_comment_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OffendingCommentBlockedEntries {
			if rel != ri {
				continue
			}

			ln := len(o.R.OffendingCommentBlockedEntries)
			if ln > 1 && i < ln-1 {
				o.R.OffendingCommentBlockedEntries[i] = o.R.OffendingCommentBlockedEntries[ln-1]
			}
			o.R.OffendingCommentBlockedEntries = o.R.OffendingCommentBlockedEntries[:ln-1]
			break
		}
	}

	return nil
}

// AddParentComments adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.ParentComments.
// Sets related.R.Parent appropriately.
func (o *Comment) AddParentComments(exec boil.Executor, insert bool, related ...*Comment) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ParentID, o.CommentID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `comment` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"parent_id"}),
				strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
			)
			values := []any{o.CommentID, rel.CommentID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ParentID, o.CommentID)
		}
	}

	if o.R == nil {
		o.R = &commentR{
			ParentComments: related,
		}
	} else {
		o.R.ParentComments = append(o.R.ParentComments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commentR{
				Parent: o,
			}
		} else {
			rel.R.Parent = o
		}
	}
	return nil
}

// SetParentComments removes all previously related items of the
// comment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Parent's ParentComments accordingly.
// Replaces o.R.ParentComments with related.
// Sets related.R.Parent's ParentComments accordingly.
func (o *Comment) SetParentComments(exec boil.Executor, insert bool, related ...*Comment) error {
	query := "update `comment` set `parent_id` = null where `parent_id` = ?"
	values := []any{o.CommentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ParentComments {
			queries.SetScanner(&rel.ParentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Parent = nil
		}
		o.R.ParentComments = nil
	}

	return o.AddParentComments(exec, insert, related...)
}

// RemoveParentComments relationships from objects passed in.
// Removes related items from R.ParentComments (uses pointer comparison, removal does not keep order)
// Sets related.R.Parent.
func (o *Comment) RemoveParentComments(exec boil.Executor, related ...*Comment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ParentID, nil)
		if rel.R != nil {
			rel.R.Parent = nil
		}
		if err = rel.Update(exec, boil.Whitelist("parent_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ParentComments {
			if rel != ri {
				continue
			}

			ln := len(o.R.ParentComments)
			if ln > 1 && i < ln-1 {
				o.R.ParentComments[i] = o.R.ParentComments[ln-1]
			}
			o.R.ParentComments = o.R.ParentComments[:ln-1]
			break
		}
	}

	return nil
}

// AddReactions adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.Reactions.
// Sets related.R.Comment appropriately.
func (o *Comment) AddReactions(exec boil.Executor, insert bool, related ...*Reaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CommentID = o.CommentID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `reaction` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"comment_id"}),
				strmangle.WhereClause("`", "`", 0, reactionPrimaryKeyColumns),
			)
			values := []any{o.CommentID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CommentID = o.CommentID
		}
	}

	if o.R == nil {
		o.R = &commentR{
			Reactions: related,
		}
	} else {
		o.R.Reactions = append(o.R.Reactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &reactionR{
				Comment: o,
			}
		} else {
			rel.R.Comment = o
		}
	}
	return nil
}

// Comments retrieves all the records using an executor.
func Comments(mods ...qm.QueryMod) commentQuery {
	mods = append(mods, qm.From("`comment`"), qmhelper.WhereIsNull("`comment`.`deleted_at`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`comment`.*"})
	}

	return commentQuery{q}
}

// FindComment retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindComment(exec boil.Executor, commentID string, selectCols ...string) (*Comment, error) {
	commentObj := &Comment{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `comment` where `comment_id`=? and `deleted_at` is null", sel,
	)

	q := queries.Raw(query, commentID)

	err := q.Bind(nil, exec, commentObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from comment")
	}

	return commentObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Comment) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no comment provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(commentColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	commentInsertCacheMut.RLock()
	cache, cached := commentInsertCache[key]
	commentInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			commentAllColumns,
			commentColumnsWithDefault,
			commentColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(commentType, commentMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(commentType, commentMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `comment` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `comment` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `comment` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	_, err = exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into comment")
	}

	var identifierCols []any

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []any{
		o.CommentID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}
	err = exec.QueryRow(cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for comment")
	}

CacheNoHooks:
	if !cached {
		commentInsertCacheMut.Lock()
		commentInsertCache[key] = cache
		commentInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Comment.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Comment) Update(exec boil.Executor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	commentUpdateCacheMut.RLock()
	cache, cached := commentUpdateCache[key]
	commentUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			commentAllColumns,
			commentPrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return errors.New("model: unable to update comment, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `comment` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(commentType, commentMapping, append(wl, commentPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err = exec.Exec(cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update comment row")
	}

	if !cached {
		commentUpdateCacheMut.Lock()
		commentUpdateCache[key] = cache
		commentUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q commentQuery) UpdateAll(exec boil.Executor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all for comment")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CommentSlice) UpdateAll(exec boil.Executor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]any, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), commentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `comment` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, commentPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all in comment slice")
	}

	return nil
}

var mySQLCommentUniqueColumns = []string{
	"comment_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Comment) Upsert(exec boil.Executor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no comment provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(commentColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCommentUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	commentUpsertCacheMut.RLock()
	cache, cached := commentUpsertCache[key]
	commentUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			commentAllColumns,
			commentColumnsWithDefault,
			commentColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			commentAllColumns,
			commentPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("model: unable to upsert comment, could not build update column list")
		}

		ret := strmangle.SetComplement(commentAllColumns, strmangle.SetIntersect(insert, update))

		cache.query = buildUpsertQueryMySQL(dialect, "`comment`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `comment` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(commentType, commentMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(commentType, commentMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []any
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	_, err = exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for comment")
	}

	var uniqueMap []uint64
	var nzUniqueCols []any

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(commentType, commentMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for comment")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}
	err = exec.QueryRow(cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for comment")
	}

CacheNoHooks:
	if !cached {
		commentUpsertCacheMut.Lock()
		commentUpsertCache[key] = cache
		commentUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Comment record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Comment) Delete(exec boil.Executor, hardDelete bool) error {
	if o == nil {
		return errors.New("model: no Comment provided for delete")
	}

	var (
		sql  string
		args []any
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), commentPrimaryKeyMapping)
		sql = "DELETE FROM `comment` WHERE `comment_id`=?"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE `comment` SET %s WHERE `comment_id`=?",
			strmangle.SetParamNames("`", "`", 0, wl),
		)
		valueMapping, err := queries.BindMapping(commentType, commentMapping, append(wl, commentPrimaryKeyColumns...))
		if err != nil {
			return err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete from comment")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q commentQuery) DeleteAll(exec boil.Executor, hardDelete bool) error {
	if q.Query == nil {
		return errors.New("model: no commentQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from comment")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CommentSlice) DeleteAll(exec boil.Executor, hardDelete bool) error {
	if len(o) == 0 {
		return nil
	}

	var (
		sql  string
		args []any
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), commentPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM `comment` WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, commentPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), commentPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE `comment` SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, commentPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("`", "`", 0, wl),
		)
		args = append([]any{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from comment slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Comment) Reload(exec boil.Executor) error {
	ret, err := FindComment(exec, o.CommentID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CommentSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CommentSlice{}
	var args []any
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), commentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `comment`.* FROM `comment` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, commentPrimaryKeyColumns, len(*o)) +
		"and `deleted_at` is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in CommentSlice")
	}

	*o = slice

	return nil
}

// CommentExists checks if the Comment row exists.
func CommentExists(exec boil.Executor, commentID string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `comment` where `comment_id`=? and `deleted_at` is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, commentID)
	}
	row := exec.QueryRow(sql, commentID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if comment exists")
	}

	return exists, nil
}

// Exists checks if the Comment row exists.
func (o *Comment) Exists(exec boil.Executor) (bool, error) {
	return CommentExists(exec, o.CommentID)
}
