// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// Comment is an object representing the database table.
type Comment struct {
	CommentID        string      `boil:"comment_id" json:"comment_id" toml:"comment_id" yaml:"comment_id"`
	LbryClaimID      string      `boil:"lbry_claim_id" json:"lbry_claim_id" toml:"lbry_claim_id" yaml:"lbry_claim_id"`
	ChannelID        null.String `boil:"channel_id" json:"channel_id,omitempty" toml:"channel_id" yaml:"channel_id,omitempty"`
	Body             string      `boil:"body" json:"body" toml:"body" yaml:"body"`
	ParentID         null.String `boil:"parent_id" json:"parent_id,omitempty" toml:"parent_id" yaml:"parent_id,omitempty"`
	Signature        null.String `boil:"signature" json:"signature,omitempty" toml:"signature" yaml:"signature,omitempty"`
	Signingts        null.String `boil:"signingts" json:"signingts,omitempty" toml:"signingts" yaml:"signingts,omitempty"`
	Timestamp        int         `boil:"timestamp" json:"timestamp" toml:"timestamp" yaml:"timestamp"`
	IsHidden         null.Bool   `boil:"is_hidden" json:"is_hidden,omitempty" toml:"is_hidden" yaml:"is_hidden,omitempty"`
	IsPinned         bool        `boil:"is_pinned" json:"is_pinned" toml:"is_pinned" yaml:"is_pinned"`
	IsFlagged        bool        `boil:"is_flagged" json:"is_flagged" toml:"is_flagged" yaml:"is_flagged"`
	Amount           null.Uint64 `boil:"amount" json:"amount,omitempty" toml:"amount" yaml:"amount,omitempty"`
	TXID             null.String `boil:"tx_id" json:"tx_id,omitempty" toml:"tx_id" yaml:"tx_id,omitempty"`
	PopularityScore  null.Int    `boil:"popularity_score" json:"popularity_score,omitempty" toml:"popularity_score" yaml:"popularity_score,omitempty"`
	ControversyScore null.Int    `boil:"controversy_score" json:"controversy_score,omitempty" toml:"controversy_score" yaml:"controversy_score,omitempty"`
	IsFiat           bool        `boil:"is_fiat" json:"is_fiat" toml:"is_fiat" yaml:"is_fiat"`
	Currency         null.String `boil:"currency" json:"currency,omitempty" toml:"currency" yaml:"currency,omitempty"`

	R *commentR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L commentL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CommentColumns = struct {
	CommentID        string
	LbryClaimID      string
	ChannelID        string
	Body             string
	ParentID         string
	Signature        string
	Signingts        string
	Timestamp        string
	IsHidden         string
	IsPinned         string
	IsFlagged        string
	Amount           string
	TXID             string
	PopularityScore  string
	ControversyScore string
	IsFiat           string
	Currency         string
}{
	CommentID:        "comment_id",
	LbryClaimID:      "lbry_claim_id",
	ChannelID:        "channel_id",
	Body:             "body",
	ParentID:         "parent_id",
	Signature:        "signature",
	Signingts:        "signingts",
	Timestamp:        "timestamp",
	IsHidden:         "is_hidden",
	IsPinned:         "is_pinned",
	IsFlagged:        "is_flagged",
	Amount:           "amount",
	TXID:             "tx_id",
	PopularityScore:  "popularity_score",
	ControversyScore: "controversy_score",
	IsFiat:           "is_fiat",
	Currency:         "currency",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpernull_Uint64 struct{ field string }

func (w whereHelpernull_Uint64) EQ(x null.Uint64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Uint64) NEQ(x null.Uint64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Uint64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Uint64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Uint64) LT(x null.Uint64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Uint64) LTE(x null.Uint64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Uint64) GT(x null.Uint64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Uint64) GTE(x null.Uint64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var CommentWhere = struct {
	CommentID        whereHelperstring
	LbryClaimID      whereHelperstring
	ChannelID        whereHelpernull_String
	Body             whereHelperstring
	ParentID         whereHelpernull_String
	Signature        whereHelpernull_String
	Signingts        whereHelpernull_String
	Timestamp        whereHelperint
	IsHidden         whereHelpernull_Bool
	IsPinned         whereHelperbool
	IsFlagged        whereHelperbool
	Amount           whereHelpernull_Uint64
	TXID             whereHelpernull_String
	PopularityScore  whereHelpernull_Int
	ControversyScore whereHelpernull_Int
	IsFiat           whereHelperbool
	Currency         whereHelpernull_String
}{
	CommentID:        whereHelperstring{field: "`comment`.`comment_id`"},
	LbryClaimID:      whereHelperstring{field: "`comment`.`lbry_claim_id`"},
	ChannelID:        whereHelpernull_String{field: "`comment`.`channel_id`"},
	Body:             whereHelperstring{field: "`comment`.`body`"},
	ParentID:         whereHelpernull_String{field: "`comment`.`parent_id`"},
	Signature:        whereHelpernull_String{field: "`comment`.`signature`"},
	Signingts:        whereHelpernull_String{field: "`comment`.`signingts`"},
	Timestamp:        whereHelperint{field: "`comment`.`timestamp`"},
	IsHidden:         whereHelpernull_Bool{field: "`comment`.`is_hidden`"},
	IsPinned:         whereHelperbool{field: "`comment`.`is_pinned`"},
	IsFlagged:        whereHelperbool{field: "`comment`.`is_flagged`"},
	Amount:           whereHelpernull_Uint64{field: "`comment`.`amount`"},
	TXID:             whereHelpernull_String{field: "`comment`.`tx_id`"},
	PopularityScore:  whereHelpernull_Int{field: "`comment`.`popularity_score`"},
	ControversyScore: whereHelpernull_Int{field: "`comment`.`controversy_score`"},
	IsFiat:           whereHelperbool{field: "`comment`.`is_fiat`"},
	Currency:         whereHelpernull_String{field: "`comment`.`currency`"},
}

// CommentRels is where relationship names are stored.
var CommentRels = struct {
	Channel        string
	Parent         string
	ParentComments string
	Reactions      string
}{
	Channel:        "Channel",
	Parent:         "Parent",
	ParentComments: "ParentComments",
	Reactions:      "Reactions",
}

// commentR is where relationships are stored.
type commentR struct {
	Channel        *Channel
	Parent         *Comment
	ParentComments CommentSlice
	Reactions      ReactionSlice
}

// NewStruct creates a new relationship struct
func (*commentR) NewStruct() *commentR {
	return &commentR{}
}

// commentL is where Load methods for each relationship are stored.
type commentL struct{}

var (
	commentAllColumns            = []string{"comment_id", "lbry_claim_id", "channel_id", "body", "parent_id", "signature", "signingts", "timestamp", "is_hidden", "is_pinned", "is_flagged", "amount", "tx_id", "popularity_score", "controversy_score", "is_fiat", "currency"}
	commentColumnsWithoutDefault = []string{"comment_id", "lbry_claim_id", "channel_id", "body", "parent_id", "signature", "signingts", "timestamp", "amount", "tx_id", "popularity_score", "controversy_score", "currency"}
	commentColumnsWithDefault    = []string{"is_hidden", "is_pinned", "is_flagged", "is_fiat"}
	commentPrimaryKeyColumns     = []string{"comment_id"}
)

type (
	// CommentSlice is an alias for a slice of pointers to Comment.
	// This should generally be used opposed to []Comment.
	CommentSlice []*Comment

	commentQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	commentType                 = reflect.TypeOf(&Comment{})
	commentMapping              = queries.MakeStructMapping(commentType)
	commentPrimaryKeyMapping, _ = queries.BindMapping(commentType, commentMapping, commentPrimaryKeyColumns)
	commentInsertCacheMut       sync.RWMutex
	commentInsertCache          = make(map[string]insertCache)
	commentUpdateCacheMut       sync.RWMutex
	commentUpdateCache          = make(map[string]updateCache)
	commentUpsertCacheMut       sync.RWMutex
	commentUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// OneG returns a single comment record from the query using the global executor.
func (q commentQuery) OneG() (*Comment, error) {
	return q.One(boil.GetDB())
}

// OneGP returns a single comment record from the query using the global executor, and panics on error.
func (q commentQuery) OneGP() *Comment {
	o, err := q.One(boil.GetDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// OneP returns a single comment record from the query, and panics on error.
func (q commentQuery) OneP(exec boil.Executor) *Comment {
	o, err := q.One(exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// One returns a single comment record from the query.
func (q commentQuery) One(exec boil.Executor) (*Comment, error) {
	o := &Comment{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for comment")
	}

	return o, nil
}

// AllG returns all Comment records from the query using the global executor.
func (q commentQuery) AllG() (CommentSlice, error) {
	return q.All(boil.GetDB())
}

// AllGP returns all Comment records from the query using the global executor, and panics on error.
func (q commentQuery) AllGP() CommentSlice {
	o, err := q.All(boil.GetDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// AllP returns all Comment records from the query, and panics on error.
func (q commentQuery) AllP(exec boil.Executor) CommentSlice {
	o, err := q.All(exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return o
}

// All returns all Comment records from the query.
func (q commentQuery) All(exec boil.Executor) (CommentSlice, error) {
	var o []*Comment

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to Comment slice")
	}

	return o, nil
}

// CountG returns the count of all Comment records in the query, and panics on error.
func (q commentQuery) CountG() (int64, error) {
	return q.Count(boil.GetDB())
}

// CountGP returns the count of all Comment records in the query using the global executor, and panics on error.
func (q commentQuery) CountGP() int64 {
	c, err := q.Count(boil.GetDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// CountP returns the count of all Comment records in the query, and panics on error.
func (q commentQuery) CountP(exec boil.Executor) int64 {
	c, err := q.Count(exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return c
}

// Count returns the count of all Comment records in the query.
func (q commentQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count comment rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q commentQuery) ExistsG() (bool, error) {
	return q.Exists(boil.GetDB())
}

// ExistsGP checks if the row exists in the table using the global executor, and panics on error.
func (q commentQuery) ExistsGP() bool {
	e, err := q.Exists(boil.GetDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// ExistsP checks if the row exists in the table, and panics on error.
func (q commentQuery) ExistsP(exec boil.Executor) bool {
	e, err := q.Exists(exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// Exists checks if the row exists in the table.
func (q commentQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if comment exists")
	}

	return count > 0, nil
}

// Channel pointed to by the foreign key.
func (o *Comment) Channel(mods ...qm.QueryMod) channelQuery {
	queryMods := []qm.QueryMod{
		qm.Where("claim_id=?", o.ChannelID),
	}

	queryMods = append(queryMods, mods...)

	query := Channels(queryMods...)
	queries.SetFrom(query.Query, "`channel`")

	return query
}

// Parent pointed to by the foreign key.
func (o *Comment) Parent(mods ...qm.QueryMod) commentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("comment_id=?", o.ParentID),
	}

	queryMods = append(queryMods, mods...)

	query := Comments(queryMods...)
	queries.SetFrom(query.Query, "`comment`")

	return query
}

// ParentComments retrieves all the comment's Comments with an executor via parent_id column.
func (o *Comment) ParentComments(mods ...qm.QueryMod) commentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`comment`.`parent_id`=?", o.CommentID),
	)

	query := Comments(queryMods...)
	queries.SetFrom(query.Query, "`comment`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`comment`.*"})
	}

	return query
}

// Reactions retrieves all the reaction's Reactions with an executor.
func (o *Comment) Reactions(mods ...qm.QueryMod) reactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`reaction`.`comment_id`=?", o.CommentID),
	)

	query := Reactions(queryMods...)
	queries.SetFrom(query.Query, "`reaction`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`reaction`.*"})
	}

	return query
}

// LoadChannel allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (commentL) LoadChannel(e boil.Executor, singular bool, maybeComment interface{}, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		object = maybeComment.(*Comment)
	} else {
		slice = *maybeComment.(*[]*Comment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		if !queries.IsNil(object.ChannelID) {
			args = append(args, object.ChannelID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ChannelID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ChannelID) {
				args = append(args, obj.ChannelID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`channel`), qm.WhereIn(`claim_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Channel")
	}

	var resultSlice []*Channel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Channel")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for channel")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for channel")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Channel = foreign
		if foreign.R == nil {
			foreign.R = &channelR{}
		}
		foreign.R.Comments = append(foreign.R.Comments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ChannelID, foreign.ClaimID) {
				local.R.Channel = foreign
				if foreign.R == nil {
					foreign.R = &channelR{}
				}
				foreign.R.Comments = append(foreign.R.Comments, local)
				break
			}
		}
	}

	return nil
}

// LoadParent allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (commentL) LoadParent(e boil.Executor, singular bool, maybeComment interface{}, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		object = maybeComment.(*Comment)
	} else {
		slice = *maybeComment.(*[]*Comment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		if !queries.IsNil(object.ParentID) {
			args = append(args, object.ParentID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ParentID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ParentID) {
				args = append(args, obj.ParentID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`comment`), qm.WhereIn(`comment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Comment")
	}

	var resultSlice []*Comment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Comment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for comment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Parent = foreign
		if foreign.R == nil {
			foreign.R = &commentR{}
		}
		foreign.R.ParentComments = append(foreign.R.ParentComments, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ParentID, foreign.CommentID) {
				local.R.Parent = foreign
				if foreign.R == nil {
					foreign.R = &commentR{}
				}
				foreign.R.ParentComments = append(foreign.R.ParentComments, local)
				break
			}
		}
	}

	return nil
}

// LoadParentComments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (commentL) LoadParentComments(e boil.Executor, singular bool, maybeComment interface{}, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		object = maybeComment.(*Comment)
	} else {
		slice = *maybeComment.(*[]*Comment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		args = append(args, object.CommentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CommentID) {
					continue Outer
				}
			}

			args = append(args, obj.CommentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`comment`), qm.WhereIn(`parent_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load comment")
	}

	var resultSlice []*Comment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice comment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on comment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for comment")
	}

	if singular {
		object.R.ParentComments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &commentR{}
			}
			foreign.R.Parent = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.CommentID, foreign.ParentID) {
				local.R.ParentComments = append(local.R.ParentComments, foreign)
				if foreign.R == nil {
					foreign.R = &commentR{}
				}
				foreign.R.Parent = local
				break
			}
		}
	}

	return nil
}

// LoadReactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (commentL) LoadReactions(e boil.Executor, singular bool, maybeComment interface{}, mods queries.Applicator) error {
	var slice []*Comment
	var object *Comment

	if singular {
		object = maybeComment.(*Comment)
	} else {
		slice = *maybeComment.(*[]*Comment)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &commentR{}
		}
		args = append(args, object.CommentID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &commentR{}
			}

			for _, a := range args {
				if a == obj.CommentID {
					continue Outer
				}
			}

			args = append(args, obj.CommentID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`reaction`), qm.WhereIn(`comment_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load reaction")
	}

	var resultSlice []*Reaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice reaction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on reaction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for reaction")
	}

	if singular {
		object.R.Reactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &reactionR{}
			}
			foreign.R.Comment = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.CommentID == foreign.CommentID {
				local.R.Reactions = append(local.R.Reactions, foreign)
				if foreign.R == nil {
					foreign.R = &reactionR{}
				}
				foreign.R.Comment = local
				break
			}
		}
	}

	return nil
}

// SetChannelG of the comment to the related item.
// Sets o.R.Channel to related.
// Adds o to related.R.Comments.
// Uses the global database handle.
func (o *Comment) SetChannelG(insert bool, related *Channel) error {
	return o.SetChannel(boil.GetDB(), insert, related)
}

// SetChannelP of the comment to the related item.
// Sets o.R.Channel to related.
// Adds o to related.R.Comments.
// Panics on error.
func (o *Comment) SetChannelP(exec boil.Executor, insert bool, related *Channel) {
	if err := o.SetChannel(exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetChannelGP of the comment to the related item.
// Sets o.R.Channel to related.
// Adds o to related.R.Comments.
// Uses the global database handle and panics on error.
func (o *Comment) SetChannelGP(insert bool, related *Channel) {
	if err := o.SetChannel(boil.GetDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetChannel of the comment to the related item.
// Sets o.R.Channel to related.
// Adds o to related.R.Comments.
func (o *Comment) SetChannel(exec boil.Executor, insert bool, related *Channel) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `comment` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"channel_id"}),
		strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
	)
	values := []interface{}{related.ClaimID, o.CommentID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ChannelID, related.ClaimID)
	if o.R == nil {
		o.R = &commentR{
			Channel: related,
		}
	} else {
		o.R.Channel = related
	}

	if related.R == nil {
		related.R = &channelR{
			Comments: CommentSlice{o},
		}
	} else {
		related.R.Comments = append(related.R.Comments, o)
	}

	return nil
}

// RemoveChannelG relationship.
// Sets o.R.Channel to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Comment) RemoveChannelG(related *Channel) error {
	return o.RemoveChannel(boil.GetDB(), related)
}

// RemoveChannelP relationship.
// Sets o.R.Channel to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Panics on error.
func (o *Comment) RemoveChannelP(exec boil.Executor, related *Channel) {
	if err := o.RemoveChannel(exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveChannelGP relationship.
// Sets o.R.Channel to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle and panics on error.
func (o *Comment) RemoveChannelGP(related *Channel) {
	if err := o.RemoveChannel(boil.GetDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveChannel relationship.
// Sets o.R.Channel to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Comment) RemoveChannel(exec boil.Executor, related *Channel) error {
	var err error

	queries.SetScanner(&o.ChannelID, nil)
	if err = o.Update(exec, boil.Whitelist("channel_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Channel = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Comments {
		if queries.Equal(o.ChannelID, ri.ChannelID) {
			continue
		}

		ln := len(related.R.Comments)
		if ln > 1 && i < ln-1 {
			related.R.Comments[i] = related.R.Comments[ln-1]
		}
		related.R.Comments = related.R.Comments[:ln-1]
		break
	}
	return nil
}

// SetParentG of the comment to the related item.
// Sets o.R.Parent to related.
// Adds o to related.R.ParentComments.
// Uses the global database handle.
func (o *Comment) SetParentG(insert bool, related *Comment) error {
	return o.SetParent(boil.GetDB(), insert, related)
}

// SetParentP of the comment to the related item.
// Sets o.R.Parent to related.
// Adds o to related.R.ParentComments.
// Panics on error.
func (o *Comment) SetParentP(exec boil.Executor, insert bool, related *Comment) {
	if err := o.SetParent(exec, insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetParentGP of the comment to the related item.
// Sets o.R.Parent to related.
// Adds o to related.R.ParentComments.
// Uses the global database handle and panics on error.
func (o *Comment) SetParentGP(insert bool, related *Comment) {
	if err := o.SetParent(boil.GetDB(), insert, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetParent of the comment to the related item.
// Sets o.R.Parent to related.
// Adds o to related.R.ParentComments.
func (o *Comment) SetParent(exec boil.Executor, insert bool, related *Comment) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `comment` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"parent_id"}),
		strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
	)
	values := []interface{}{related.CommentID, o.CommentID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ParentID, related.CommentID)
	if o.R == nil {
		o.R = &commentR{
			Parent: related,
		}
	} else {
		o.R.Parent = related
	}

	if related.R == nil {
		related.R = &commentR{
			ParentComments: CommentSlice{o},
		}
	} else {
		related.R.ParentComments = append(related.R.ParentComments, o)
	}

	return nil
}

// RemoveParentG relationship.
// Sets o.R.Parent to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Comment) RemoveParentG(related *Comment) error {
	return o.RemoveParent(boil.GetDB(), related)
}

// RemoveParentP relationship.
// Sets o.R.Parent to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Panics on error.
func (o *Comment) RemoveParentP(exec boil.Executor, related *Comment) {
	if err := o.RemoveParent(exec, related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveParentGP relationship.
// Sets o.R.Parent to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle and panics on error.
func (o *Comment) RemoveParentGP(related *Comment) {
	if err := o.RemoveParent(boil.GetDB(), related); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveParent relationship.
// Sets o.R.Parent to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Comment) RemoveParent(exec boil.Executor, related *Comment) error {
	var err error

	queries.SetScanner(&o.ParentID, nil)
	if err = o.Update(exec, boil.Whitelist("parent_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Parent = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ParentComments {
		if queries.Equal(o.ParentID, ri.ParentID) {
			continue
		}

		ln := len(related.R.ParentComments)
		if ln > 1 && i < ln-1 {
			related.R.ParentComments[i] = related.R.ParentComments[ln-1]
		}
		related.R.ParentComments = related.R.ParentComments[:ln-1]
		break
	}
	return nil
}

// AddParentCommentsG adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.ParentComments.
// Sets related.R.Parent appropriately.
// Uses the global database handle.
func (o *Comment) AddParentCommentsG(insert bool, related ...*Comment) error {
	return o.AddParentComments(boil.GetDB(), insert, related...)
}

// AddParentCommentsP adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.ParentComments.
// Sets related.R.Parent appropriately.
// Panics on error.
func (o *Comment) AddParentCommentsP(exec boil.Executor, insert bool, related ...*Comment) {
	if err := o.AddParentComments(exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddParentCommentsGP adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.ParentComments.
// Sets related.R.Parent appropriately.
// Uses the global database handle and panics on error.
func (o *Comment) AddParentCommentsGP(insert bool, related ...*Comment) {
	if err := o.AddParentComments(boil.GetDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddParentComments adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.ParentComments.
// Sets related.R.Parent appropriately.
func (o *Comment) AddParentComments(exec boil.Executor, insert bool, related ...*Comment) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ParentID, o.CommentID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `comment` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"parent_id"}),
				strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
			)
			values := []interface{}{o.CommentID, rel.CommentID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ParentID, o.CommentID)
		}
	}

	if o.R == nil {
		o.R = &commentR{
			ParentComments: related,
		}
	} else {
		o.R.ParentComments = append(o.R.ParentComments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &commentR{
				Parent: o,
			}
		} else {
			rel.R.Parent = o
		}
	}
	return nil
}

// SetParentCommentsG removes all previously related items of the
// comment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Parent's ParentComments accordingly.
// Replaces o.R.ParentComments with related.
// Sets related.R.Parent's ParentComments accordingly.
// Uses the global database handle.
func (o *Comment) SetParentCommentsG(insert bool, related ...*Comment) error {
	return o.SetParentComments(boil.GetDB(), insert, related...)
}

// SetParentCommentsP removes all previously related items of the
// comment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Parent's ParentComments accordingly.
// Replaces o.R.ParentComments with related.
// Sets related.R.Parent's ParentComments accordingly.
// Panics on error.
func (o *Comment) SetParentCommentsP(exec boil.Executor, insert bool, related ...*Comment) {
	if err := o.SetParentComments(exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetParentCommentsGP removes all previously related items of the
// comment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Parent's ParentComments accordingly.
// Replaces o.R.ParentComments with related.
// Sets related.R.Parent's ParentComments accordingly.
// Uses the global database handle and panics on error.
func (o *Comment) SetParentCommentsGP(insert bool, related ...*Comment) {
	if err := o.SetParentComments(boil.GetDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// SetParentComments removes all previously related items of the
// comment replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Parent's ParentComments accordingly.
// Replaces o.R.ParentComments with related.
// Sets related.R.Parent's ParentComments accordingly.
func (o *Comment) SetParentComments(exec boil.Executor, insert bool, related ...*Comment) error {
	query := "update `comment` set `parent_id` = null where `parent_id` = ?"
	values := []interface{}{o.CommentID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ParentComments {
			queries.SetScanner(&rel.ParentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Parent = nil
		}

		o.R.ParentComments = nil
	}
	return o.AddParentComments(exec, insert, related...)
}

// RemoveParentCommentsG relationships from objects passed in.
// Removes related items from R.ParentComments (uses pointer comparison, removal does not keep order)
// Sets related.R.Parent.
// Uses the global database handle.
func (o *Comment) RemoveParentCommentsG(related ...*Comment) error {
	return o.RemoveParentComments(boil.GetDB(), related...)
}

// RemoveParentCommentsP relationships from objects passed in.
// Removes related items from R.ParentComments (uses pointer comparison, removal does not keep order)
// Sets related.R.Parent.
// Panics on error.
func (o *Comment) RemoveParentCommentsP(exec boil.Executor, related ...*Comment) {
	if err := o.RemoveParentComments(exec, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveParentCommentsGP relationships from objects passed in.
// Removes related items from R.ParentComments (uses pointer comparison, removal does not keep order)
// Sets related.R.Parent.
// Uses the global database handle and panics on error.
func (o *Comment) RemoveParentCommentsGP(related ...*Comment) {
	if err := o.RemoveParentComments(boil.GetDB(), related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// RemoveParentComments relationships from objects passed in.
// Removes related items from R.ParentComments (uses pointer comparison, removal does not keep order)
// Sets related.R.Parent.
func (o *Comment) RemoveParentComments(exec boil.Executor, related ...*Comment) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ParentID, nil)
		if rel.R != nil {
			rel.R.Parent = nil
		}
		if err = rel.Update(exec, boil.Whitelist("parent_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ParentComments {
			if rel != ri {
				continue
			}

			ln := len(o.R.ParentComments)
			if ln > 1 && i < ln-1 {
				o.R.ParentComments[i] = o.R.ParentComments[ln-1]
			}
			o.R.ParentComments = o.R.ParentComments[:ln-1]
			break
		}
	}

	return nil
}

// AddReactionsG adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.Reactions.
// Sets related.R.Comment appropriately.
// Uses the global database handle.
func (o *Comment) AddReactionsG(insert bool, related ...*Reaction) error {
	return o.AddReactions(boil.GetDB(), insert, related...)
}

// AddReactionsP adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.Reactions.
// Sets related.R.Comment appropriately.
// Panics on error.
func (o *Comment) AddReactionsP(exec boil.Executor, insert bool, related ...*Reaction) {
	if err := o.AddReactions(exec, insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddReactionsGP adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.Reactions.
// Sets related.R.Comment appropriately.
// Uses the global database handle and panics on error.
func (o *Comment) AddReactionsGP(insert bool, related ...*Reaction) {
	if err := o.AddReactions(boil.GetDB(), insert, related...); err != nil {
		panic(boil.WrapErr(err))
	}
}

// AddReactions adds the given related objects to the existing relationships
// of the comment, optionally inserting them as new records.
// Appends related to o.R.Reactions.
// Sets related.R.Comment appropriately.
func (o *Comment) AddReactions(exec boil.Executor, insert bool, related ...*Reaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CommentID = o.CommentID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `reaction` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"comment_id"}),
				strmangle.WhereClause("`", "`", 0, reactionPrimaryKeyColumns),
			)
			values := []interface{}{o.CommentID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CommentID = o.CommentID
		}
	}

	if o.R == nil {
		o.R = &commentR{
			Reactions: related,
		}
	} else {
		o.R.Reactions = append(o.R.Reactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &reactionR{
				Comment: o,
			}
		} else {
			rel.R.Comment = o
		}
	}
	return nil
}

// Comments retrieves all the records using an executor.
func Comments(mods ...qm.QueryMod) commentQuery {
	mods = append(mods, qm.From("`comment`"))
	return commentQuery{NewQuery(mods...)}
}

// FindCommentG retrieves a single record by ID.
func FindCommentG(commentID string, selectCols ...string) (*Comment, error) {
	return FindComment(boil.GetDB(), commentID, selectCols...)
}

// FindCommentP retrieves a single record by ID with an executor, and panics on error.
func FindCommentP(exec boil.Executor, commentID string, selectCols ...string) *Comment {
	retobj, err := FindComment(exec, commentID, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindCommentGP retrieves a single record by ID, and panics on error.
func FindCommentGP(commentID string, selectCols ...string) *Comment {
	retobj, err := FindComment(boil.GetDB(), commentID, selectCols...)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return retobj
}

// FindComment retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindComment(exec boil.Executor, commentID string, selectCols ...string) (*Comment, error) {
	commentObj := &Comment{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `comment` where `comment_id`=?", sel,
	)

	q := queries.Raw(query, commentID)

	err := q.Bind(nil, exec, commentObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from comment")
	}

	return commentObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Comment) InsertG(columns boil.Columns) error {
	return o.Insert(boil.GetDB(), columns)
}

// InsertP a single record using an executor, and panics on error. See Insert
// for whitelist behavior description.
func (o *Comment) InsertP(exec boil.Executor, columns boil.Columns) {
	if err := o.Insert(exec, columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// InsertGP a single record, and panics on error. See Insert for whitelist
// behavior description.
func (o *Comment) InsertGP(columns boil.Columns) {
	if err := o.Insert(boil.GetDB(), columns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Comment) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no comment provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(commentColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	commentInsertCacheMut.RLock()
	cache, cached := commentInsertCache[key]
	commentInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			commentAllColumns,
			commentColumnsWithDefault,
			commentColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(commentType, commentMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(commentType, commentMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `comment` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `comment` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `comment` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into comment")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.CommentID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRow(cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for comment")
	}

CacheNoHooks:
	if !cached {
		commentInsertCacheMut.Lock()
		commentInsertCache[key] = cache
		commentInsertCacheMut.Unlock()
	}

	return nil
}

// UpdateG a single Comment record using the global executor.
// See Update for more documentation.
func (o *Comment) UpdateG(columns boil.Columns) error {
	return o.Update(boil.GetDB(), columns)
}

// UpdateP uses an executor to update the Comment, and panics on error.
// See Update for more documentation.
func (o *Comment) UpdateP(exec boil.Executor, columns boil.Columns) {
	err := o.Update(exec, columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpdateGP a single Comment record using the global executor. Panics on error.
// See Update for more documentation.
func (o *Comment) UpdateGP(columns boil.Columns) {
	err := o.Update(boil.GetDB(), columns)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// Update uses an executor to update the Comment.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Comment) Update(exec boil.Executor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	commentUpdateCacheMut.RLock()
	cache, cached := commentUpdateCache[key]
	commentUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			commentAllColumns,
			commentPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return errors.New("model: unable to update comment, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `comment` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, commentPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(commentType, commentMapping, append(wl, commentPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	_, err = exec.Exec(cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update comment row")
	}

	if !cached {
		commentUpdateCacheMut.Lock()
		commentUpdateCache[key] = cache
		commentUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAllP updates all rows with matching column names, and panics on error.
func (q commentQuery) UpdateAllP(exec boil.Executor, cols M) {
	err := q.UpdateAll(exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpdateAllG updates all rows with the specified column values.
func (q commentQuery) UpdateAllG(cols M) error {
	return q.UpdateAll(boil.GetDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q commentQuery) UpdateAll(exec boil.Executor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all for comment")
	}

	return nil
}

// UpdateAllG updates all rows with the specified column values.
func (o CommentSlice) UpdateAllG(cols M) error {
	return o.UpdateAll(boil.GetDB(), cols)
}

// UpdateAllGP updates all rows with the specified column values, and panics on error.
func (o CommentSlice) UpdateAllGP(cols M) {
	err := o.UpdateAll(boil.GetDB(), cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpdateAllP updates all rows with the specified column values, and panics on error.
func (o CommentSlice) UpdateAllP(exec boil.Executor, cols M) {
	err := o.UpdateAll(exec, cols)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CommentSlice) UpdateAll(exec boil.Executor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), commentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `comment` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, commentPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all in comment slice")
	}

	return nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Comment) UpsertG(updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(boil.GetDB(), updateColumns, insertColumns)
}

// UpsertGP attempts an insert, and does an update or ignore on conflict. Panics on error.
func (o *Comment) UpsertGP(updateColumns, insertColumns boil.Columns) {
	if err := o.Upsert(boil.GetDB(), updateColumns, insertColumns); err != nil {
		panic(boil.WrapErr(err))
	}
}

// UpsertP attempts an insert using an executor, and does an update or ignore on conflict.
// UpsertP panics on error.
func (o *Comment) UpsertP(exec boil.Executor, updateColumns, insertColumns boil.Columns) {
	if err := o.Upsert(exec, updateColumns, insertColumns); err != nil {
		panic(boil.WrapErr(err))
	}
}

var mySQLCommentUniqueColumns = []string{
	"comment_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Comment) Upsert(exec boil.Executor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no comment provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(commentColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCommentUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	commentUpsertCacheMut.RLock()
	cache, cached := commentUpsertCache[key]
	commentUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			commentAllColumns,
			commentColumnsWithDefault,
			commentColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			commentAllColumns,
			commentPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("model: unable to upsert comment, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "comment", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `comment` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(commentType, commentMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(commentType, commentMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	_, err = exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for comment")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(commentType, commentMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for comment")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRow(cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for comment")
	}

CacheNoHooks:
	if !cached {
		commentUpsertCacheMut.Lock()
		commentUpsertCache[key] = cache
		commentUpsertCacheMut.Unlock()
	}

	return nil
}

// DeleteG deletes a single Comment record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Comment) DeleteG() error {
	return o.Delete(boil.GetDB())
}

// DeleteP deletes a single Comment record with an executor.
// DeleteP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Comment) DeleteP(exec boil.Executor) {
	err := o.Delete(exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// DeleteGP deletes a single Comment record.
// DeleteGP will match against the primary key column to find the record to delete.
// Panics on error.
func (o *Comment) DeleteGP() {
	err := o.Delete(boil.GetDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// Delete deletes a single Comment record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Comment) Delete(exec boil.Executor) error {
	if o == nil {
		return errors.New("model: no Comment provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), commentPrimaryKeyMapping)
	sql := "DELETE FROM `comment` WHERE `comment_id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete from comment")
	}

	return nil
}

// DeleteAllP deletes all rows, and panics on error.
func (q commentQuery) DeleteAllP(exec boil.Executor) {
	err := q.DeleteAll(exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// DeleteAll deletes all matching rows.
func (q commentQuery) DeleteAll(exec boil.Executor) error {
	if q.Query == nil {
		return errors.New("model: no commentQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from comment")
	}

	return nil
}

// DeleteAllG deletes all rows in the slice.
func (o CommentSlice) DeleteAllG() error {
	return o.DeleteAll(boil.GetDB())
}

// DeleteAllP deletes all rows in the slice, using an executor, and panics on error.
func (o CommentSlice) DeleteAllP(exec boil.Executor) {
	err := o.DeleteAll(exec)
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// DeleteAllGP deletes all rows in the slice, and panics on error.
func (o CommentSlice) DeleteAllGP() {
	err := o.DeleteAll(boil.GetDB())
	if err != nil {
		panic(boil.WrapErr(err))
	}
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CommentSlice) DeleteAll(exec boil.Executor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), commentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `comment` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, commentPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from comment slice")
	}

	return nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Comment) ReloadG() error {
	if o == nil {
		return errors.New("model: no Comment provided for reload")
	}

	return o.Reload(boil.GetDB())
}

// ReloadP refetches the object from the database with an executor. Panics on error.
func (o *Comment) ReloadP(exec boil.Executor) {
	if err := o.Reload(exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadGP refetches the object from the database and panics on error.
func (o *Comment) ReloadGP() {
	if err := o.Reload(boil.GetDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Comment) Reload(exec boil.Executor) error {
	ret, err := FindComment(exec, o.CommentID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CommentSlice) ReloadAllG() error {
	if o == nil {
		return errors.New("model: empty CommentSlice provided for reload all")
	}

	return o.ReloadAll(boil.GetDB())
}

// ReloadAllP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *CommentSlice) ReloadAllP(exec boil.Executor) {
	if err := o.ReloadAll(exec); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAllGP refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
// Panics on error.
func (o *CommentSlice) ReloadAllGP() {
	if err := o.ReloadAll(boil.GetDB()); err != nil {
		panic(boil.WrapErr(err))
	}
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CommentSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CommentSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), commentPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `comment`.* FROM `comment` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, commentPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in CommentSlice")
	}

	*o = slice

	return nil
}

// CommentExistsG checks if the Comment row exists.
func CommentExistsG(commentID string) (bool, error) {
	return CommentExists(boil.GetDB(), commentID)
}

// CommentExistsP checks if the Comment row exists. Panics on error.
func CommentExistsP(exec boil.Executor, commentID string) bool {
	e, err := CommentExists(exec, commentID)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// CommentExistsGP checks if the Comment row exists. Panics on error.
func CommentExistsGP(commentID string) bool {
	e, err := CommentExists(boil.GetDB(), commentID)
	if err != nil {
		panic(boil.WrapErr(err))
	}

	return e
}

// CommentExists checks if the Comment row exists.
func CommentExists(exec boil.Executor, commentID string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `comment` where `comment_id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, commentID)
	}

	row := exec.QueryRow(sql, commentID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if comment exists")
	}

	return exists, nil
}
